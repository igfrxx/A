local offset = 1100
local invisible = false
local grips = {}
local heldTool
local gripChanged
local handle
local weld
local originalAnimateState -- To store whether Animate was enabled originally

function setDisplayDistance(distance)
    for _, player in pairs(game.Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChildWhichIsA("Humanoid") then
            player.Character:FindFirstChildWhichIsA("Humanoid").NameDisplayDistance = distance
            player.Character:FindFirstChildWhichIsA("Humanoid").HealthDisplayDistance = distance
        end
    end
end

function invis()
    if not invisible then
        invisible = true
        
        -- Store original animate state
        originalAnimateState = game.Players.LocalPlayer.Character.Animate.Enabled
        
        -- Disable all animations
        game.Players.LocalPlayer.Character.Animate.Enabled = false
        for _, track in pairs(game.Players.LocalPlayer.Character.Humanoid:GetPlayingAnimationTracks()) do
            track:Stop()
        end
        
        -- Handle invisibility setup
        if handle then handle:Destroy() end
        if weld then weld:Destroy() end
        
        handle = Instance.new("Part", workspace)
        handle.Name = "Handle"
        handle.Transparency = 1
        handle.CanCollide = false
        handle.Size = Vector3.new(2, 1, 1)
        
        weld = Instance.new("Weld", handle)
        weld.Part0 = handle
        weld.Part1 = game.Players.LocalPlayer.Character.HumanoidRootPart
        weld.C0 = CFrame.new(0, offset - 1.5, 0)
        
        setDisplayDistance(offset + 100)
        workspace.CurrentCamera.CameraSubject = handle
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, offset, 0)
        game.Players.LocalPlayer.Character.Humanoid.HipHeight = offset
        game.Players.LocalPlayer.Character.Humanoid:ChangeState(11)
        
        -- Store original tool grips
        for _, child in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
            if child:IsA("Tool") then
                grips[child] = child.Grip
            end
        end
    end
end

function vis()
    if invisible then
        invisible = false
        
        -- Clean up invisibility parts
        if handle then handle:Destroy() end
        if weld then weld:Destroy() end
        
        -- Restore animations to original state
        game.Players.LocalPlayer.Character.Animate.Enabled = originalAnimateState or true
        
        -- Return tools to normal state
        for _, child in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
            if child:IsA("Tool") then
                child.Parent = game.Players.LocalPlayer.Backpack
            end
        end
        
        for tool, grip in pairs(grips) do
            if tool then
                tool.Grip = grip
            end
        end
        
        heldTool = nil
        setDisplayDistance(100)
        workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character.Humanoid
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, -offset, 0)
        game.Players.LocalPlayer.Character.Humanoid.HipHeight = 0
        
        -- Make the character jump
        game.Players.LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end

-- Tool handling for when tools are equipped while invisible
game.Players.LocalPlayer.Character.ChildAdded:Connect(function(child)
    wait()
    if invisible and child:IsA("Tool") and child ~= heldTool then
        heldTool = child
        local lastGrip = heldTool.Grip
        if not grips[heldTool] then
            grips[heldTool] = lastGrip
        end
        
        -- Ensure animations stay disabled for tools
        game.Players.LocalPlayer.Character.Animate.Enabled = false
        for _, track in pairs(game.Players.LocalPlayer.Character.Humanoid:GetPlayingAnimationTracks()) do
            track:Stop()
        end
        
        heldTool.Grip = heldTool.Grip * (CFrame.new(0, offset - 1.5, 1.5) * CFrame.Angles(math.rad(-90), 0, 0))
        heldTool.Parent = game.Players.LocalPlayer.Backpack
        heldTool.Parent = game.Players.LocalPlayer.Character
        
        if gripChanged then
            gripChanged:Disconnect()
        end
        
        gripChanged = heldTool:GetPropertyChangedSignal("Grip"):Connect(function()
            wait()
            if not invisible then
                gripChanged:Disconnect()
            end
            if heldTool.Grip ~= lastGrip then
                lastGrip = heldTool.Grip * (CFrame.new(0, offset - 1.5, 1.5) * CFrame.Angles(math.rad(-90), 0, 0))
                heldTool.Grip = lastGrip
                heldTool.Parent = game.Players.LocalPlayer.Backpack
                heldTool.Parent = game.Players.LocalPlayer.Character
            end
        end)
    end
end)


local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/hm5650/Rayfield/refs/heads/main/RayField'))()
local Window = Rayfield:CreateWindow({
   Name = "Swordblox⚔️",
   Icon = 125153819502786, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "SwordBlox⚔️ {v0.5}", -- VZ
   LoadingSubtitle = "Script Made By Hmmm5650",
   Theme = "AmberGlow", -- Check 

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "sb"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use sbhbomething unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local Tab = Window:CreateTab("Info", "info")
local Label = Tab:CreateLabel("YT: @hmmm5650", "play")
local Paragraph = Tab:CreateParagraph({Title = "[About]", Content = "Swordblox is a completely free to use exploit with no KeySystems and has enough features to destroy your victims"})
local Paragraph = Tab:CreateParagraph({Title = "[UpdateLog]", Content = "Added invisible Toggle | Bugfixes 12"})
local Tab = Window:CreateTab("Local", "user")

-- Get all players for the dropdown options
local players = game:GetService("Players"):GetPlayers()
local playerNames = {}
for _, player in ipairs(players) do
    table.insert(playerNames, player.Name)
end

-- Teleport to player dropdown
local Dropdown = Tab:CreateDropdown({
    Name = "Teleport to player",
    Options = playerNames,
    CurrentOption = playerNames[1] or "No players",
    MultipleOptions = false,
    Flag = "PlayerDropdown",
    Callback = function(selectedPlayer)
        local target = game:GetService("Players"):FindFirstChild(selectedPlayer[1])
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            game.Players.LocalPlayer.Character:MoveTo(target.Character.HumanoidRootPart.Position)
        end
    end,
})

-- Walkspeed toggle and slider with linked functionality
local walkspeedEnabled = false
local currentWalkspeed = 16 -- Default walkspeed

local Toggle = Tab:CreateToggle({
    Name = "Change Walkspeed",
    CurrentValue = false,
    Flag = "WalkspeedToggle",
    Callback = function(Value)
        walkspeedEnabled = Value
        local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            if walkspeedEnabled then
                humanoid.WalkSpeed = currentWalkspeed
            else
                humanoid.WalkSpeed = 16 -- Reset to default
            end
        end
    end,
})

local Slider = Tab:CreateSlider({
    Name = "Walkspeed Value",
    Range = {16, 100}, -- Minimum is normal walkspeed
    Increment = 1,
    Suffix = "studs/s",
    CurrentValue = 16,
    Flag = "WalkspeedSlider",
    Callback = function(Value)
        currentWalkspeed = Value
        if walkspeedEnabled then
            local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = Value
            end
        end
    end,
})

local Divider = Tab:CreateDivider()

local ToggleJump = Tab:CreateToggle({
    Name = "Change JumpPower",
    CurrentValue = false,
    Flag = "JumpPowerToggle",
    Callback = function(Value)
        jumpPowerEnabled = Value
        local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            if jumpPowerEnabled then
                humanoid.JumpPower = currentJumpPower
            else
                humanoid.JumpPower = 50 -- Reset to default (typical Roblox default)
            end
        end
    end,
})

local SliderJump = Tab:CreateSlider({
    Name = "JumpPower Value",
    Range = {50, 200}, -- Minimum is normal jump power
    Increment = 1,
    Suffix = "power",
    CurrentValue = 50,
    Flag = "JumpPowerSlider",
    Callback = function(Value)
        currentJumpPower = Value
        if jumpPowerEnabled then
            local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.JumpPower = Value
            end
        end
    end,
})

local Toggle = Tab:CreateToggle({
   Name = "Invisible",
   CurrentValue = false,
   Flag = "Togglinvise1",
   Callback = function(Value)
      if Value then
         invis()
      else
         vis()
      end
   end,
})

local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- GUI Setup
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BHopGUI"
screenGui.ResetOnSpawn = false
screenGui.Enabled = false -- Controlled by external toggle
screenGui.Parent = player:WaitForChild("PlayerGui")

-- BHop Button
local bhopButton = Instance.new("TextButton")
bhopButton.Name = "BHopButton"
bhopButton.Size = UDim2.new(0, 120, 0, 50)
bhopButton.Position = UDim2.new(0, 60, 0, 60)
bhopButton.BackgroundColor3 = Color3.fromRGB(75, 151, 75)
bhopButton.BackgroundTransparency = 0.3
bhopButton.TextColor3 = Color3.fromRGB(255, 255, 255)
bhopButton.Text = "BHop: OFF"
bhopButton.Font = Enum.Font.Gotham
bhopButton.TextSize = 14
bhopButton.Active = true
bhopButton.Draggable = true
bhopButton.Parent = screenGui

-- Rounded corners
local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0.3, 0)
uiCorner.Parent = bhopButton

-- BHop State
local bhopEnabled = false

-- Toggle Text + State
bhopButton.MouseButton1Click:Connect(function()
    bhopEnabled = not bhopEnabled
    bhopButton.Text = "BHop: " .. (bhopEnabled and "ON" or "OFF")
end)

-- Auto BHop Loop
task.spawn(function()
    while true do
        task.wait(0.03)
        if bhopEnabled then
            local character = player.Character
            if character and character:FindFirstChild("Humanoid") then
                local humanoid = character.Humanoid
                if humanoid:GetState() == Enum.HumanoidStateType.Running or humanoid:GetState() == Enum.HumanoidStateType.Landed then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        end
    end
end)

local Toggle = Tab:CreateToggle({
   Name = "Bhop",
   CurrentValue = false,
   Flag = "Togglebhop", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
   screenGui.Enabled = Value
   end,
})

-- Add player list refresh button
local Button = Tab:CreateButton({
    Name = "Refresh Player List",
    Callback = function()
        local players = game:GetService("Players"):GetPlayers()
        local newNames = {}
        for _, player in ipairs(players) do
            table.insert(newNames, player.Name)
        end
        
        -- Update dropdown options
        Dropdown:Refresh({
            Options = newNames,
            CurrentOption = newNames[1] or "No players"
        })
    end
})

local Tab = Window:CreateTab("Visuals", "eye")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local ESP = {
    Enabled = false,
    TeamCheck = false,
    TeamColor = Color3.fromRGB(0, 0, 255),
    EnemyColor = Color3.fromRGB(255, 0, 0),
    DefaultColor = Color3.fromRGB(255, 255, 255),
    HighlightInstances = {},
    Connections = {} -- To track all event connections
}

-- Cleanup function to remove all highlights and connections
local function cleanup()
    -- Remove all highlights
    for player, highlight in pairs(ESP.HighlightInstances) do
        if highlight and highlight.Parent then
            highlight:Destroy()
        end
    end
    ESP.HighlightInstances = {}
    
    -- Disconnect all events
    for _, connection in pairs(ESP.Connections) do
        connection:Disconnect()
    end
    ESP.Connections = {}
end

local function createHighlight(character, player)
    if not character or not character:IsDescendantOf(workspace) then return end
    
    -- Remove existing highlight if it exists
    if ESP.HighlightInstances[player] then
        ESP.HighlightInstances[player]:Destroy()
    end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight_" .. player.UserId
    highlight.Adornee = character
    highlight.Parent = character
    
    -- Update color based on current settings
    if ESP.TeamCheck then
        local localPlayer = Players.LocalPlayer
        if localPlayer and localPlayer.Team and player.Team then
            if player.Team == localPlayer.Team then
                highlight.FillColor = ESP.TeamColor
                highlight.OutlineColor = ESP.TeamColor
            else
                highlight.FillColor = ESP.EnemyColor
                highlight.OutlineColor = ESP.EnemyColor
            end
        else
            highlight.FillColor = ESP.DefaultColor
            highlight.OutlineColor = ESP.DefaultColor
        end
    else
        highlight.FillColor = ESP.DefaultColor
        highlight.OutlineColor = ESP.DefaultColor
    end
    
    ESP.HighlightInstances[player] = highlight
    
    -- Connect to character removal
    local connection
    connection = character.AncestryChanged:Connect(function(_, parent)
        if not parent and character.Parent == nil then
            if highlight and highlight.Parent then
                highlight:Destroy()
            end
            connection:Disconnect()
        end
    end)
    
    table.insert(ESP.Connections, connection)
    
    return highlight
end

local function onCharacterAdded(character, player)
    if not ESP.Enabled then return end
    
    -- Wait for the character to fully load
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        -- Handle cases where humanoid might not be ready immediately
        if humanoid:GetState() == Enum.HumanoidStateType.Dead then
            local connection
            connection = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
                if humanoid.Health > 0 then
                    createHighlight(character, player)
                    connection:Disconnect()
                end
            end)
            table.insert(ESP.Connections, connection)
        else
            createHighlight(character, player)
        end
    else
        -- If humanoid isn't found, wait for it
        local connection
        connection = character.ChildAdded:Connect(function(child)
            if child:IsA("Humanoid") then
                createHighlight(character, player)
                connection:Disconnect()
            end
        end)
        table.insert(ESP.Connections, connection)
    end
    
    -- Handle respawns by watching for humanoid death
    local humanoid = character:WaitForChild("Humanoid")
    local diedConnection
    diedConnection = humanoid.Died:Connect(function()
        if ESP.HighlightInstances[player] then
            ESP.HighlightInstances[player]:Destroy()
            ESP.HighlightInstances[player] = nil
        end
        
        -- Wait for respawn
        local respawnConnection
        respawnConnection = player.CharacterAdded:Connect(function(newChar)
            if ESP.Enabled then
                onCharacterAdded(newChar, player)
            end
            respawnConnection:Disconnect()
        end)
        table.insert(ESP.Connections, respawnConnection)
    end)
    table.insert(ESP.Connections, diedConnection)
end

local function onPlayerAdded(player)
    if player == Players.LocalPlayer then return end
    
    -- Connect character added event
    local charAddedConn = player.CharacterAdded:Connect(function(character)
        onCharacterAdded(character, player)
    end)
    table.insert(ESP.Connections, charAddedConn)
    
    -- Connect team change event
    local teamChangedConn = player:GetPropertyChangedSignal("Team"):Connect(function()
        if ESP.Enabled and ESP.TeamCheck and player.Character then
            local highlight = ESP.HighlightInstances[player]
            if highlight then
                local localPlayer = Players.LocalPlayer
                if localPlayer and localPlayer.Team and player.Team then
                    if player.Team == localPlayer.Team then
                        highlight.FillColor = ESP.TeamColor
                        highlight.OutlineColor = ESP.TeamColor
                    else
                        highlight.FillColor = ESP.EnemyColor
                        highlight.OutlineColor = ESP.EnemyColor
                    end
                else
                    highlight.FillColor = ESP.DefaultColor
                    highlight.OutlineColor = ESP.DefaultColor
                end
            end
        end
    end)
    table.insert(ESP.Connections, teamChangedConn)
    
    -- Handle existing character
    if player.Character then
        onCharacterAdded(player.Character, player)
    end
end

local function removePlayer(player)
    if ESP.HighlightInstances[player] then
        ESP.HighlightInstances[player]:Destroy()
        ESP.HighlightInstances[player] = nil
    end
end

local function toggleESP(enable)
    ESP.Enabled = enable
    
    if enable then
        cleanup() -- Clean up any existing highlights/connections
        
        -- Add highlights to existing players
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer then
                onPlayerAdded(player)
            end
        end
        
        -- Connect to player added/removed events
        table.insert(ESP.Connections, Players.PlayerAdded:Connect(onPlayerAdded))
        table.insert(ESP.Connections, Players.PlayerRemoving:Connect(removePlayer))
    else
        cleanup()
    end
end

-- Initialize team change handler for local player
local localPlayer = Players.LocalPlayer
if localPlayer then
    table.insert(ESP.Connections, localPlayer:GetPropertyChangedSignal("Team"):Connect(function()
        if ESP.Enabled and ESP.TeamCheck then
            for player, highlight in pairs(ESP.HighlightInstances) do
                if player.Character then
                    if localPlayer.Team and player.Team then
                        if player.Team == localPlayer.Team then
                            highlight.FillColor = ESP.TeamColor
                            highlight.OutlineColor = ESP.TeamColor
                        else
                            highlight.FillColor = ESP.EnemyColor
                            highlight.OutlineColor = ESP.EnemyColor
                        end
                    else
                        highlight.FillColor = ESP.DefaultColor
                        highlight.OutlineColor = ESP.DefaultColor
                    end
                end
            end
        end
    end))
end

-- Create UI elements
local Toggle = Tab:CreateToggle({
    Name = "ESP",
    CurrentValue = false,
    Flag = "ESP_Toggle",
    Callback = function(Value)
        toggleESP(Value)
    end,
})

local TeamToggle = Tab:CreateToggle({
    Name = "Team Check",
    CurrentValue = false,
    Flag = "TeamCheck_Toggle",
    Callback = function(Value)
        ESP.TeamCheck = Value
        if ESP.Enabled then
            -- Force update all highlights when team check is toggled
            for player, highlight in pairs(ESP.HighlightInstances) do
                if highlight and highlight.Parent then
                    if Value then
                        local localPlayer = Players.LocalPlayer
                        if localPlayer and localPlayer.Team and player.Team then
                            if player.Team == localPlayer.Team then
                                highlight.FillColor = ESP.TeamColor
                                highlight.OutlineColor = ESP.TeamColor
                            else
                                highlight.FillColor = ESP.EnemyColor
                                highlight.OutlineColor = ESP.EnemyColor
                            end
                        else
                            highlight.FillColor = ESP.DefaultColor
                            highlight.OutlineColor = ESP.DefaultColor
                        end
                    else
                        highlight.FillColor = ESP.DefaultColor
                        highlight.OutlineColor = ESP.DefaultColor
                    end
                end
            end
        end
    end
})

local Section = Tab:CreateSection("[ Esp Color Configuration ]")

local TeamColorPicker = Tab:CreateColorPicker({
    Name = "Team Color",
    Color = ESP.TeamColor,
    Flag = "TeamColor_Picker",
    Callback = function(Value)
        ESP.TeamColor = Value
        if ESP.Enabled and ESP.TeamCheck then
            for player, highlight in pairs(ESP.HighlightInstances) do
                if highlight and highlight.Parent then
                    local localPlayer = Players.LocalPlayer
                    if localPlayer and localPlayer.Team and player.Team and player.Team == localPlayer.Team then
                        highlight.FillColor = Value
                        highlight.OutlineColor = Value
                    end
                end
            end
        end
    end
})

local EnemyColorPicker = Tab:CreateColorPicker({
    Name = "Enemy Color",
    Color = ESP.EnemyColor,
    Flag = "EnemyColor_Picker",
    Callback = function(Value)
        ESP.EnemyColor = Value
        if ESP.Enabled and ESP.TeamCheck then
            for player, highlight in pairs(ESP.HighlightInstances) do
                if highlight and highlight.Parent then
                    local localPlayer = Players.LocalPlayer
                    if localPlayer and localPlayer.Team and player.Team and player.Team ~= localPlayer.Team then
                        highlight.FillColor = Value
                        highlight.OutlineColor = Value
                    end
                end
            end
        end
    end
})

local DefaultColorPicker = Tab:CreateColorPicker({
    Name = "Default Color",
    Color = ESP.DefaultColor,
    Flag = "DefaultColor_Picker",
    Callback = function(Value)
        ESP.DefaultColor = Value
        if ESP.Enabled then
            for player, highlight in pairs(ESP.HighlightInstances) do
                if highlight and highlight.Parent then
                    if not ESP.TeamCheck then
                        highlight.FillColor = Value
                        highlight.OutlineColor = Value
                    else
                        local localPlayer = Players.LocalPlayer
                        if not (localPlayer and localPlayer.Team and player.Team) then
                            highlight.FillColor = Value
                            highlight.OutlineColor = Value
                        end
                    end
                end
            end
        end
    end
})

local Tab = Window:CreateTab("Misc", "box")

local Button = Tab:CreateButton({
   Name = "ShifLock",
   Callback = function()
   loadstring(game:HttpGet("https://github.com/ltseverydayyou/uuuuuuu/blob/main/shiftlock?raw=true"))()
   end,
})

local Tab = Window:CreateTab("Admins", "user-check")

local Button = Tab:CreateButton({
   Name = "Infinite Yield",
   Callback = function()
   loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
   end,
})

local Button = Tab:CreateButton({
   Name = "Nameless Admin",
   Callback = function()
   loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Nameless-Admin-Official-15022"))()
   end,
})

local Button = Tab:CreateButton({
   Name = "Nameless Admin [V2]",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Nameless-admin-14114"))()
   end,
})

local Section = Tab:CreateSection("Try Our Admin Panel :)")

local Button = Tab:CreateButton({
   Name = "TerminalCmd",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/TCmd/refs/heads/main/TerminalCmd", true))()
   end,
})

-- [Previous code remains the same until the Sword Modification tab]

local Tab = Window:CreateTab("Sword Modification", "sword") -- Using sword icon (you can change this)

-- Reach system variables
local active = false
local dmgEnabled = false 
local visualizerEnabled = false
local currentReach = 3.5
local visualizerColor = Color3.fromRGB(255, 0, 0)
local hurtboxType = "Sphere" -- Default hurtbox type
local visualizerMaterial = "ForceField" -- Default visualizer material

-- Material mapping
local materialMap = {
    ["ForceField"] = Enum.Material.ForceField,
    ["Plastic"] = Enum.Material.Plastic,
    ["Glass"] = Enum.Material.Glass,
    ["Neon"] = Enum.Material.Neon,
    ["SmoothPlastic"] = Enum.Material.SmoothPlastic,
    ["Metal"] = Enum.Material.Metal,
    ["DiamondPlate"] = Enum.Material.DiamondPlate
}

-- Visualizer setup
local visualizer = Instance.new("Part") 
visualizer.BrickColor = BrickColor.new(visualizerColor)
visualizer.Transparency = 0.6 
visualizer.Anchored = true 
visualizer.CanCollide = false 
visualizer.Size = Vector3.new(0.5, 0.5, 0.5) 
visualizer.BottomSurface = Enum.SurfaceType.Smooth 
visualizer.TopSurface = Enum.SurfaceType.Smooth 
visualizer.Material = Enum.Material.ForceField -- Default material

-- Create UI elements
local Section = Tab:CreateSection("[ Req, Sword ]")
local WarningSection = Tab:CreateSection("[ May Get You Banned ]")

local Toggle = Tab:CreateToggle({
   Name = "Start Reach [High  Risk]",
   CurrentValue = false,
   Flag = "HTBEToggle",
   Callback = function(Value)
        active = Value
   end,
})

Tab:CreateSection("Options")

local Toggle = Tab:CreateToggle({
   Name = "High Dmg [Low Risk]",
   CurrentValue = false,
   Flag = "HighDmgToggle",
   Callback = function(Value)
        dmgEnabled = Value
   end,
})

Tab:CreateSection("[ You Would Need To Update The ReachSize A Little For Instant Kill To Work]")

local instantKillEnabled = false

local Toggle = Tab:CreateToggle({
   Name = "Instant Kill [High Risk]",
   CurrentValue = false,
   Flag = "InstantKillToggle",
   Callback = function(Value)
        instantKillEnabled = Value
   end,
})

local Toggle = Tab:CreateToggle({
   Name = "Visualizer",
   CurrentValue = false,
   Flag = "VisualizerToggle",
   Callback = function(Value)
        visualizerEnabled = Value
        if not Value then
            visualizer.Parent = nil
        end
   end,
})

local Section = Tab:CreateSection("Flat (REC) For Instant Kills")

-- Add the new Hurtbox Type dropdown (only Sphere and Flat now)
local Dropdown = Tab:CreateDropdown({
    Name = "Reach Type",
    Options = {"Sphere", "Flat"},
    CurrentOption = "Sphere",
    MultipleOptions = false,
    Flag = "HurtboxTypeDropdown",
    Callback = function(selectedType)
        hurtboxType = selectedType[1]
    end,
})

-- Add the new Visualizer Material dropdown
local MaterialDropdown = Tab:CreateDropdown({
    Name = "Visualizer Material",
    Options = {"ForceField", "Plastic", "Glass", "Neon", "SmoothPlastic", "Metal", "DiamondPlate"},
    CurrentOption = "ForceField",
    MultipleOptions = false,
    Flag = "VisualizerMaterialDropdown",
    Callback = function(selectedMaterial)
        visualizerMaterial = selectedMaterial[1]
        if visualizer.Parent then
            visualizer.Material = materialMap[visualizerMaterial]
        end
    end,
})

local Input = Tab:CreateInput({
   Name = "ReachSize [Textbox]",
   CurrentValue = "3.5",
   PlaceholderText = "3.5",
   Flag = "HurtboxInput",
   Callback = function(Text)
        currentReach = tonumber(Text) or 3.5
   end,
})

local Slider = Tab:CreateSlider({
   Name = "ReachSize [Slider]",
   Range = {0.1, 200},
   Increment = 5,
   Suffix = "units",
   CurrentValue = 3.5,
   Flag = "HurtboxSlider",
   Callback = function(Value)
        currentReach = Value
   end,
})

Tab:CreateSection("Visuals")

local ColorPicker = Tab:CreateColorPicker({
    Name = "Visualizer Color",
    Color = visualizerColor,
    Flag = "HurtboxColor",
    Callback = function(Value)
        visualizerColor = Value
        visualizer.Color = Value
    end
})

-- Reach functionality
local function onHit(hit, handle)
    local victim = hit.Parent:FindFirstChildOfClass("Humanoid") 
    if victim and victim.Parent.Name ~= game.Players.LocalPlayer.Name then 
        if dmgEnabled or instantKillEnabled then 
            for _,v in pairs(hit.Parent:GetChildren()) do 
                if v:IsA("Part") then 
                    firetouchinterest(v, handle, 0) 
                    firetouchinterest(v, handle, 1) 
                    if instantKillEnabled then
                        -- Extra damage for instant kill
                        for i = 1, 5 do
                            firetouchinterest(v, handle, 0)
                            firetouchinterest(v, handle, 1)
                            task.wait()
                        end
                    end
                end 
            end 
        else 
            firetouchinterest(hit, handle, 0) 
            firetouchinterest(hit, handle, 1) 
        end 
    end 
end

local function getWhiteList() 
    local wl = {} 
    for _,v in pairs(game.Players:GetPlayers()) do 
        if v ~= game.Players.LocalPlayer then 
            local char = v.Character 
            if char then 
                for _,q in pairs(char:GetChildren()) do 
                    if q:IsA("Part") then 
                        table.insert(wl, q) 
                    end 
                end 
            end 
        end 
    end 
    return wl 
end 

-- Main loop
game:GetService("RunService").RenderStepped:Connect(function() 
    if not active then 
        visualizer.Parent = nil
        return 
    end 
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local tool = character:FindFirstChildOfClass("Tool") 
    if not tool then 
        visualizer.Parent = nil
        return 
    end 
    
    local handle = tool:FindFirstChild("Handle") or tool:FindFirstChildOfClass("Part") 
    if not handle then 
        visualizer.Parent = nil
        return 
    end 
    
    -- Update visualizer if enabled
    if visualizerEnabled then 
        visualizer.Parent = workspace 
        visualizer.Material = materialMap[visualizerMaterial] or Enum.Material.ForceField
        
        -- Set shape based on selected hurtbox type
        if hurtboxType == "Sphere" then
            visualizer.Shape = Enum.PartType.Ball
            visualizer.Size = Vector3.new(currentReach, currentReach, currentReach)
            visualizer.CFrame = handle.CFrame
        elseif hurtboxType == "Flat" then
            visualizer.Shape = Enum.PartType.Block
            visualizer.Size = Vector3.new(currentReach, 0.2, currentReach)
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                visualizer.CFrame = CFrame.new(rootPart.Position) * CFrame.new(0, -2.5, 0)
            end
        end
        
        visualizer.Color = visualizerColor
    else 
        visualizer.Parent = nil 
    end 
    
    -- Check for hits
    for _,v in pairs(game.Players:GetPlayers()) do 
        local hrp = v.Character and v.Character:FindFirstChild("HumanoidRootPart") 
        if hrp and handle then 
            local mag = (hrp.Position - handle.Position).magnitude 
            if mag <= currentReach then 
                onHit(hrp, handle) 
            end 
        end 
    end 
end)

-- [Rest of the code remains the same]

Tab:CreateSection("Extras")

local Button = Tab:CreateButton({
   Name = "Kill All [Low Risk]",
   Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/InstantKillig/refs/heads/main/Coolkillguithingy", true))()
   end,
})

local Toggle = Tab:CreateToggle({
   Name = "Auto Swing",
   CurrentValue = false,
   Flag = "AutoSwingToggle",
   Callback = function(Value)
        if Value then
            _G.AutoSwing = true
            while _G.AutoSwing do
                pcall(function()
                    game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Tool"):Activate()
                end)
                wait(0.1)
            end
        else
            _G.AutoSwing = false
        end
   end,
})

local Tab = Window:CreateTab("Protection", "shield")

local Button = Tab:CreateButton({
   Name = "Remove AntiCheats [RECOMMEND]",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/G/refs/heads/main/G"))()
   end,
})

local voidprotection = false

-- VoidProtection
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

local monitoring = false
local connection
local highestY = hrp.Position.Y
local lastPropulsionHeight = 0
local consecutiveBounces = 0

local function onCharacterAdded(newCharacter)
    character = newCharacter
    hrp = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    highestY = hrp.Position.Y
    lastPropulsionHeight = 0
    consecutiveBounces = 0
end

player.CharacterAdded:Connect(onCharacterAdded)

-- Function to check if player is on a platform
local function isOnPlatform()
    if not humanoid then return false end
    return humanoid.FloorMaterial ~= Enum.Material.Air
end

function VoidProtectionOn()
    if monitoring then return end
    monitoring = true

    connection = RunService.Heartbeat:Connect(function()
        if not character or not character:FindFirstChild("HumanoidRootPart") then return end

        local currentY = hrp.Position.Y

        -- Reset system if player is on a platform
        if isOnPlatform() then
            highestY = currentY
            consecutiveBounces = 0
            return
        end

        -- Update the highest point if we're ascending
        if hrp.Velocity.Y > 0 then
            highestY = currentY
        end

        -- Check if we've fallen below the void level
        if currentY < -105 then
            local fallDistance = highestY - currentY
            
            -- Increase bounce strength based on consecutive bounces
            consecutiveBounces = consecutiveBounces + 1
            local bounceMultiplier = 2 + (consecutiveBounces * 0.5) -- Each bounce increases power by 50%
            local bounceVelocity = math.clamp(fallDistance * bounceMultiplier, 100, 500)

            hrp.Velocity = Vector3.new(0, bounceVelocity, 0)

            -- Store the height we were propelled from
            lastPropulsionHeight = currentY
        end
    end)
end

function VoidProtectionOff()
    if connection then
        connection:Disconnect()
    end
    monitoring = false
end

-- Initialize based on the variable
if voidprotection then
    VoidProtectionOn()
else
    VoidProtectionOff()
end

local Toggle = Tab:CreateToggle({
   Name = "VoidProtection",
   CurrentValue = false,
   Flag = "VPTogglr",
   Callback = function(Value)
       voidprotection = Value
       if Value then
           VoidProtectionOn()
       else
           VoidProtectionOff()
       end
   end,
})

-- Initialize variables
getgenv().HowFastDanSchneiderCatchesYou = 1
getgenv().HowMuchDanSchneiderTouchesYou = 15
getgenv().HowMuchDanSchneiderTouchedYou = 25
getgenv().Daddy_Catches_You = false


-- Create main tab
local MainTab = Window:CreateTab("SwordBot", "monitor")

-- Create sliders
MainTab:CreateSlider({
    Name = "Rotation Speed",
    Range = {0, 10},
    Increment = 0.01,
    Suffix = "Speed",
    CurrentValue = 1,
    Flag = "RotoSpeed",
    Callback = function(Value)
        getgenv().HowFastDanSchneiderCatchesYou = Value
    end,
})

MainTab:CreateSlider({
    Name = "Sword Range",
    Range = {0, 30},
    Increment = 1,
    Suffix = "Studs",
    CurrentValue = 15,
    Flag = "SwordRange",
    Callback = function(Value)
        getgenv().HowMuchDanSchneiderTouchesYou = Value
    end,
})

MainTab:CreateSlider({
    Name = "Attack Range",
    Range = {0, 10000},
    Increment = 50,
    Suffix = "Studs",
    CurrentValue = 25,
    Flag = "AttackRange",
    Callback = function(Value)
        getgenv().HowMuchDanSchneiderTouchedYou = Value
    end,
})

-- Create toggle for the auto-attack
MainTab:CreateToggle({
    Name = "Auto Attack",
    CurrentValue = false,
    Flag = "AutoAttackToggle",
    Callback = function(Value)
        getgenv().Daddy_Catches_You = Value
    end,
})

-- Set up the main functionality
game:GetService("RunService").RenderStepped:Connect(function()
    if getgenv().Daddy_Catches_You == true then
        spawn(function()
            local tool = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if tool and tool:FindFirstChild("Handle") then
                tool:Activate()
                local p = game.Players:GetPlayers()
                for i = 2, #p do
                    local v = p[i].Character
                    if v and v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 and v:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer:DistanceFromCharacter(v.HumanoidRootPart.Position) <= getgenv().HowMuchDanSchneiderTouchesYou then
                        for i,v in next, v:GetChildren() do
                            if v:IsA("BasePart") then
                                firetouchinterest(tool.Handle,v,0)
                                firetouchinterest(tool.Handle,v,1)
                            end
                        end
                    end
                end
            end
        end)
    end
end)

local function getClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = getgenv().HowMuchDanSchneiderTouchedYou
    for i, v in pairs(game:GetService("Players"):GetPlayers()) do
        if v ~= game.Players.LocalPlayer then
            if v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 and v.Character:FindFirstChild("HumanoidRootPart") then
                if not v.Character:FindFirstChildOfClass("ForceField") then
                    local magnitude = (v.Character.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).magnitude
                    if magnitude < shortestDistance then
                        closestPlayer = v
                        shortestDistance = magnitude
                    end
                end
            end
        end
    end
    return closestPlayer
end

-- Disable unwanted humanoid states
local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)

-- Main loop
game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().Daddy_Catches_You and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local target = getClosestPlayer()
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.AutoRotate = false
                local root = game.Players.LocalPlayer.Character.HumanoidRootPart
                local targetPos = target.Character.HumanoidRootPart.Position
                root.CFrame = root.CFrame:Lerp(CFrame.new(root.Position, Vector3.new(targetPos.X, root.Position.Y, targetPos.Z)) * CFrame.Angles(0, math.rad(25), 0), getgenv().HowFastDanSchneiderCatchesYou)
                humanoid:MoveTo(target.Character.HumanoidRootPart.CFrame * CFrame.new(-3, 0, 0).p)
                
                if target.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                    humanoid.Jump = true
                end
            end
        end
    else
        local humanoid = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.AutoRotate = true
        end
    end
end)


local Tab = Window:CreateTab("Health", "heart")

local Section = Tab:CreateSection("[ SUPPORTED EXEC ]")
local Section = Tab:CreateSection("Delta - Mobile")
local Section = Tab:CreateSection("idk srry - Pc")

local Button = Tab:CreateButton({
    Name = "ResetHealth",
    Callback = function()
        local h = game.Players.LocalPlayer.Character.HumanoidRootPart
        local cam = workspace.CurrentCamera
        if replicatesignal then
            replicatesignal(game.Players.LocalPlayer.ConnectDiedSignalBackend)
        else
            print("Can't do ResetHealth because replicatesignal function not supported")
        end
        wait(game.Players.RespawnTime - .165)
        game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState(15)
        wait(0.5)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = h.CFrame
        workspace.CurrentCamera = cam
    end,
})

local damageToggle = false
local damageConnection = nil
local respawnCooldown = false

-- Improved error handling with pcall
local function safeReplicateSignal()
    if not replicatesignal then return false end
    local success, err = pcall(function()
        replicatesignal(game.Players.LocalPlayer.ConnectDiedSignalBackend)
    end)
    if not success then
        warn("Failed to replicate signal:", err)
        return false
    end
    return true
end

-- Handles the damage event with more safety checks
local function setupDamageListener()
    -- Cleanup existing listener
    if damageConnection then
        damageConnection:Disconnect()
        damageConnection = nil
    end

    local player = game.Players.LocalPlayer
    if not player then return end

    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    -- Store respawn position and camera
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local cam = workspace.CurrentCamera
    local maxHealth = humanoid.MaxHealth

    -- Connect the damage listener with additional checks
    damageConnection = humanoid.HealthChanged:Connect(function(currentHealth)
        if not damageToggle or respawnCooldown then return end
        if currentHealth >= maxHealth then return end
        
        -- Prevent multiple triggers
        respawnCooldown = true
        
        -- Attempt to replicate signal
        local signalReplicated = safeReplicateSignal()
        
        -- Calculate wait time with safety margin
        local respawnTime = math.max(0, game.Players.RespawnTime - 0.165)
        
        task.wait(respawnTime)
        
        -- Additional safety check before changing state
        if humanoid and humanoid.Health <= 0 then
            humanoid:ChangeState(Enum.HumanoidStateType.Dead)
        end
        
        task.wait(0.5)
        
        -- Verify everything exists before teleporting
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and hrp then
            player.Character.HumanoidRootPart.CFrame = hrp.CFrame
        end
        
        -- Restore camera if it exists
        if cam and cam.Parent then
            workspace.CurrentCamera = cam
        end
        
        -- Reset cooldown after everything completes
        task.delay(1, function()
            respawnCooldown = false
        end)
    end)
end

-- Improved character added handler with retry logic
local function onCharacterAdded(character)
    if not damageToggle then return end
    
    local maxRetries = 3
    local retryDelay = 1
    
    for i = 1, maxRetries do
        task.wait(retryDelay)
        
        -- Check if humanoid exists yet
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            setupDamageListener()
            break
        end
        
        if i == maxRetries then
            warn("Failed to setup damage listener after", maxRetries, "attempts")
        end
    end
end

-- Toggle with additional safety
local Toggle = Tab:CreateToggle({
    Name = "Auto Respawn",
    CurrentValue = false,
    Flag = "AutoResetHealthToggle",
    Callback = function(Value)
        damageToggle = Value

        if Value then
            -- Delay setup to ensure character is loaded
            task.spawn(function()
                if game.Players.LocalPlayer.Character then
                    setupDamageListener()
                end
            end)
        else
            if damageConnection then
                damageConnection:Disconnect()
                damageConnection = nil
            end
        end
    end,
})

-- More robust character tracking
local player = game.Players.LocalPlayer
if player then
    -- Handle initial character
    if player.Character then
        task.spawn(onCharacterAdded, player.Character)
    end
    
    -- Handle future characters
    player.CharacterAdded:Connect(onCharacterAdded)
end

-- [[ THIS IS A SNIPPET ]] --

-- Import the Library
local fnl = loadstring(game:HttpGetAsync 'https://raw.githubusercontent.com/Code1Tech/utils/main/notification.lua')()

-- Make a Notification function
function notify(title, text, duration)
  title = title or "Notification"
  text = text or "No text provided."
  duration = duration or 5
  
  fnl:MakeNotification({
    Title = title,
    Text = text,
    Duration = duration
  })
end

-- [ LoadsScriptResources ]
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/LoadResources/refs/heads/main/ResSourcesLoaderSource", true))()
warn("StartedScript")
end)

-- Use the func
notify("GUI Loaded", "Thanks For Using SwordBlox :) Script made by hmmm5650", 4)
